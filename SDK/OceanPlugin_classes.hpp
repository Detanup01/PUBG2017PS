#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OceanPlugin

#include "Basic.hpp"

#include "OceanPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class OceanPlugin.BuoyantDestructibleComponent
// 0x0050 (0x0A10 - 0x09C0)
class UBuoyantDestructibleComponent final : public UDestructibleComponent
{
public:
	uint8                                         Pad_9C0[0x8];                                      // 0x09C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOceanManager*                          OceanManager;                                      // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChunkDensity;                                      // 0x09D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidDensity;                                      // 0x09D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidLinearDamping;                                // 0x09D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidAngularDamping;                               // 0x09DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityDamper;                                    // 0x09E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ClampMaxVelocity;                                  // 0x09EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9ED[0x3];                                      // 0x09ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxUnderwaterVelocity;                             // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestPointRadius;                                   // 0x09F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugPoints;                                   // 0x09F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableWaveForces;                                  // 0x09F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FA[0x2];                                      // 0x09FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveForceMultiplier;                               // 0x09FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChunkSleepThreshold;                               // 0x0A00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChunkStabilizationThreshold;                       // 0x0A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x8];                                      // 0x0A08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuoyantDestructibleComponent">();
	}
	static class UBuoyantDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuoyantDestructibleComponent>();
	}
};
static_assert(alignof(UBuoyantDestructibleComponent) == 0x000010, "Wrong alignment on UBuoyantDestructibleComponent");
static_assert(sizeof(UBuoyantDestructibleComponent) == 0x000A10, "Wrong size on UBuoyantDestructibleComponent");
static_assert(offsetof(UBuoyantDestructibleComponent, OceanManager) == 0x0009C8, "Member 'UBuoyantDestructibleComponent::OceanManager' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, ChunkDensity) == 0x0009D0, "Member 'UBuoyantDestructibleComponent::ChunkDensity' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, FluidDensity) == 0x0009D4, "Member 'UBuoyantDestructibleComponent::FluidDensity' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, FluidLinearDamping) == 0x0009D8, "Member 'UBuoyantDestructibleComponent::FluidLinearDamping' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, FluidAngularDamping) == 0x0009DC, "Member 'UBuoyantDestructibleComponent::FluidAngularDamping' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, VelocityDamper) == 0x0009E0, "Member 'UBuoyantDestructibleComponent::VelocityDamper' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, ClampMaxVelocity) == 0x0009EC, "Member 'UBuoyantDestructibleComponent::ClampMaxVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, MaxUnderwaterVelocity) == 0x0009F0, "Member 'UBuoyantDestructibleComponent::MaxUnderwaterVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, TestPointRadius) == 0x0009F4, "Member 'UBuoyantDestructibleComponent::TestPointRadius' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, DrawDebugPoints) == 0x0009F8, "Member 'UBuoyantDestructibleComponent::DrawDebugPoints' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, EnableWaveForces) == 0x0009F9, "Member 'UBuoyantDestructibleComponent::EnableWaveForces' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, WaveForceMultiplier) == 0x0009FC, "Member 'UBuoyantDestructibleComponent::WaveForceMultiplier' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, ChunkSleepThreshold) == 0x000A00, "Member 'UBuoyantDestructibleComponent::ChunkSleepThreshold' has a wrong offset!");
static_assert(offsetof(UBuoyantDestructibleComponent, ChunkStabilizationThreshold) == 0x000A04, "Member 'UBuoyantDestructibleComponent::ChunkStabilizationThreshold' has a wrong offset!");

// Class OceanPlugin.WaterHeightmapComponent
// 0x0078 (0x0170 - 0x00F8)
class UWaterHeightmapComponent final : public UActorComponent
{
public:
	float                                         DesiredCellSize;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyCollidingComponents;                          // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridSizeMultiplier;                                // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawUsedTriangles;                                // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawHeightmap;                                    // 0x0105(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x62];                                     // 0x0106(0x0062)(Fixing Size After Last Property [ Dumper-7 ])
	class AOceanManager*                          OceanManager;                                      // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterHeightmapComponent">();
	}
	static class UWaterHeightmapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterHeightmapComponent>();
	}
};
static_assert(alignof(UWaterHeightmapComponent) == 0x000008, "Wrong alignment on UWaterHeightmapComponent");
static_assert(sizeof(UWaterHeightmapComponent) == 0x000170, "Wrong size on UWaterHeightmapComponent");
static_assert(offsetof(UWaterHeightmapComponent, DesiredCellSize) == 0x0000F8, "Member 'UWaterHeightmapComponent::DesiredCellSize' has a wrong offset!");
static_assert(offsetof(UWaterHeightmapComponent, bOnlyCollidingComponents) == 0x0000FC, "Member 'UWaterHeightmapComponent::bOnlyCollidingComponents' has a wrong offset!");
static_assert(offsetof(UWaterHeightmapComponent, GridSizeMultiplier) == 0x000100, "Member 'UWaterHeightmapComponent::GridSizeMultiplier' has a wrong offset!");
static_assert(offsetof(UWaterHeightmapComponent, bDrawUsedTriangles) == 0x000104, "Member 'UWaterHeightmapComponent::bDrawUsedTriangles' has a wrong offset!");
static_assert(offsetof(UWaterHeightmapComponent, bDrawHeightmap) == 0x000105, "Member 'UWaterHeightmapComponent::bDrawHeightmap' has a wrong offset!");
static_assert(offsetof(UWaterHeightmapComponent, OceanManager) == 0x000168, "Member 'UWaterHeightmapComponent::OceanManager' has a wrong offset!");

// Class OceanPlugin.BuoyancyForceComponent
// 0x00A0 (0x03A0 - 0x0300)
class UBuoyancyForceComponent : public USceneComponent
{
public:
	class AOceanManager*                          OceanManager;                                      // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshDensity;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidDensity;                                      // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidLinearDamping;                                // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidAngularDamping;                               // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityDamper;                                    // 0x0318(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ClampMaxVelocity;                                  // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxUnderwaterVelocity;                             // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestPointRadius;                                   // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TestPoints;                                        // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ApplyForceToBones;                                 // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapToSurfaceIfNoPhysics;                          // 0x0341(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TwoGerstnerIterations;                             // 0x0342(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_343[0x5];                                      // 0x0343(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PointDensityOverride;                              // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FStructBoneOverride>            BoneOverride;                                      // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          DrawDebugPoints;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableStayUprightConstraint;                       // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x2];                                      // 0x036A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightStiffness;                              // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightDamping;                                // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StayUprightDesiredRotation;                        // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          EnableWaveForces;                                  // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveForceMultiplier;                               // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETickingGroup                                 TickGroup;                                         // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x17];                                     // 0x0389(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuoyancyForceComponent">();
	}
	static class UBuoyancyForceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuoyancyForceComponent>();
	}
};
static_assert(alignof(UBuoyancyForceComponent) == 0x000008, "Wrong alignment on UBuoyancyForceComponent");
static_assert(sizeof(UBuoyancyForceComponent) == 0x0003A0, "Wrong size on UBuoyancyForceComponent");
static_assert(offsetof(UBuoyancyForceComponent, OceanManager) == 0x000300, "Member 'UBuoyancyForceComponent::OceanManager' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, MeshDensity) == 0x000308, "Member 'UBuoyancyForceComponent::MeshDensity' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, FluidDensity) == 0x00030C, "Member 'UBuoyancyForceComponent::FluidDensity' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, FluidLinearDamping) == 0x000310, "Member 'UBuoyancyForceComponent::FluidLinearDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, FluidAngularDamping) == 0x000314, "Member 'UBuoyancyForceComponent::FluidAngularDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, VelocityDamper) == 0x000318, "Member 'UBuoyancyForceComponent::VelocityDamper' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, ClampMaxVelocity) == 0x000324, "Member 'UBuoyancyForceComponent::ClampMaxVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, MaxUnderwaterVelocity) == 0x000328, "Member 'UBuoyancyForceComponent::MaxUnderwaterVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, TestPointRadius) == 0x00032C, "Member 'UBuoyancyForceComponent::TestPointRadius' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, TestPoints) == 0x000330, "Member 'UBuoyancyForceComponent::TestPoints' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, ApplyForceToBones) == 0x000340, "Member 'UBuoyancyForceComponent::ApplyForceToBones' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, SnapToSurfaceIfNoPhysics) == 0x000341, "Member 'UBuoyancyForceComponent::SnapToSurfaceIfNoPhysics' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, TwoGerstnerIterations) == 0x000342, "Member 'UBuoyancyForceComponent::TwoGerstnerIterations' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, PointDensityOverride) == 0x000348, "Member 'UBuoyancyForceComponent::PointDensityOverride' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, BoneOverride) == 0x000358, "Member 'UBuoyancyForceComponent::BoneOverride' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, DrawDebugPoints) == 0x000368, "Member 'UBuoyancyForceComponent::DrawDebugPoints' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, EnableStayUprightConstraint) == 0x000369, "Member 'UBuoyancyForceComponent::EnableStayUprightConstraint' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, StayUprightStiffness) == 0x00036C, "Member 'UBuoyancyForceComponent::StayUprightStiffness' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, StayUprightDamping) == 0x000370, "Member 'UBuoyancyForceComponent::StayUprightDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, StayUprightDesiredRotation) == 0x000374, "Member 'UBuoyancyForceComponent::StayUprightDesiredRotation' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, EnableWaveForces) == 0x000380, "Member 'UBuoyancyForceComponent::EnableWaveForces' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, WaveForceMultiplier) == 0x000384, "Member 'UBuoyancyForceComponent::WaveForceMultiplier' has a wrong offset!");
static_assert(offsetof(UBuoyancyForceComponent, TickGroup) == 0x000388, "Member 'UBuoyancyForceComponent::TickGroup' has a wrong offset!");

// Class OceanPlugin.OceanManager
// 0x0088 (0x0428 - 0x03A0)
class AOceanManager final : public AActor
{
public:
	bool                                          EnableGerstnerWaves;                               // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              GlobalWaveDirection;                               // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GlobalWaveSpeed;                                   // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalWaveAmplitude;                               // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceCheck;                                     // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWaveParameter>                 WaveClusters;                                      // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWaveSetParameters>             WaveSetOffsetsOverride;                            // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         NetWorkTimeOffset;                                 // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLandscapeModulation;                        // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModulationStartHeight;                             // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModulationMaxHeight;                               // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModulationPower;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALandscape*                             Landscape;                                         // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeightmapTexture;                                  // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x28];                                     // 0x0400(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetWaveHeightValue(const struct FVector& Location, const class UWorld* World, bool HeightOnly, bool TwoIterations);
	void LoadLandscapeHeightmap(class UTexture2D* Tex2D);

	struct FLinearColor GetHeightmapPixel(float U, float V) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OceanManager">();
	}
	static class AOceanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOceanManager>();
	}
};
static_assert(alignof(AOceanManager) == 0x000008, "Wrong alignment on AOceanManager");
static_assert(sizeof(AOceanManager) == 0x000428, "Wrong size on AOceanManager");
static_assert(offsetof(AOceanManager, EnableGerstnerWaves) == 0x0003A0, "Member 'AOceanManager::EnableGerstnerWaves' has a wrong offset!");
static_assert(offsetof(AOceanManager, GlobalWaveDirection) == 0x0003A4, "Member 'AOceanManager::GlobalWaveDirection' has a wrong offset!");
static_assert(offsetof(AOceanManager, GlobalWaveSpeed) == 0x0003AC, "Member 'AOceanManager::GlobalWaveSpeed' has a wrong offset!");
static_assert(offsetof(AOceanManager, GlobalWaveAmplitude) == 0x0003B0, "Member 'AOceanManager::GlobalWaveAmplitude' has a wrong offset!");
static_assert(offsetof(AOceanManager, DistanceCheck) == 0x0003B4, "Member 'AOceanManager::DistanceCheck' has a wrong offset!");
static_assert(offsetof(AOceanManager, WaveClusters) == 0x0003B8, "Member 'AOceanManager::WaveClusters' has a wrong offset!");
static_assert(offsetof(AOceanManager, WaveSetOffsetsOverride) == 0x0003C8, "Member 'AOceanManager::WaveSetOffsetsOverride' has a wrong offset!");
static_assert(offsetof(AOceanManager, NetWorkTimeOffset) == 0x0003D8, "Member 'AOceanManager::NetWorkTimeOffset' has a wrong offset!");
static_assert(offsetof(AOceanManager, bEnableLandscapeModulation) == 0x0003DC, "Member 'AOceanManager::bEnableLandscapeModulation' has a wrong offset!");
static_assert(offsetof(AOceanManager, ModulationStartHeight) == 0x0003E0, "Member 'AOceanManager::ModulationStartHeight' has a wrong offset!");
static_assert(offsetof(AOceanManager, ModulationMaxHeight) == 0x0003E4, "Member 'AOceanManager::ModulationMaxHeight' has a wrong offset!");
static_assert(offsetof(AOceanManager, ModulationPower) == 0x0003E8, "Member 'AOceanManager::ModulationPower' has a wrong offset!");
static_assert(offsetof(AOceanManager, Landscape) == 0x0003F0, "Member 'AOceanManager::Landscape' has a wrong offset!");
static_assert(offsetof(AOceanManager, HeightmapTexture) == 0x0003F8, "Member 'AOceanManager::HeightmapTexture' has a wrong offset!");

// Class OceanPlugin.BuoyancyComponent
// 0x0088 (0x01C8 - 0x0140)
class UBuoyancyComponent final : public UMovementComponent
{
public:
	class AOceanManager*                          OceanManager;                                      // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshDensity;                                       // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidDensity;                                      // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidLinearDamping;                                // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidAngularDamping;                               // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityDamper;                                    // 0x0158(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ClampMaxVelocity;                                  // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxUnderwaterVelocity;                             // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestPointRadius;                                   // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TestPoints;                                        // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 PointDensityOverride;                              // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          DrawDebugPoints;                                   // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableStayUprightConstraint;                       // 0x0191(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192[0x2];                                      // 0x0192(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightStiffness;                              // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightDamping;                                // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StayUprightDesiredRotation;                        // 0x019C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          EnableWaveForces;                                  // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveForceMultiplier;                               // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x18];                                     // 0x01B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuoyancyComponent">();
	}
	static class UBuoyancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuoyancyComponent>();
	}
};
static_assert(alignof(UBuoyancyComponent) == 0x000008, "Wrong alignment on UBuoyancyComponent");
static_assert(sizeof(UBuoyancyComponent) == 0x0001C8, "Wrong size on UBuoyancyComponent");
static_assert(offsetof(UBuoyancyComponent, OceanManager) == 0x000140, "Member 'UBuoyancyComponent::OceanManager' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, MeshDensity) == 0x000148, "Member 'UBuoyancyComponent::MeshDensity' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, FluidDensity) == 0x00014C, "Member 'UBuoyancyComponent::FluidDensity' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, FluidLinearDamping) == 0x000150, "Member 'UBuoyancyComponent::FluidLinearDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, FluidAngularDamping) == 0x000154, "Member 'UBuoyancyComponent::FluidAngularDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, VelocityDamper) == 0x000158, "Member 'UBuoyancyComponent::VelocityDamper' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, ClampMaxVelocity) == 0x000164, "Member 'UBuoyancyComponent::ClampMaxVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, MaxUnderwaterVelocity) == 0x000168, "Member 'UBuoyancyComponent::MaxUnderwaterVelocity' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, TestPointRadius) == 0x00016C, "Member 'UBuoyancyComponent::TestPointRadius' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, TestPoints) == 0x000170, "Member 'UBuoyancyComponent::TestPoints' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, PointDensityOverride) == 0x000180, "Member 'UBuoyancyComponent::PointDensityOverride' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, DrawDebugPoints) == 0x000190, "Member 'UBuoyancyComponent::DrawDebugPoints' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, EnableStayUprightConstraint) == 0x000191, "Member 'UBuoyancyComponent::EnableStayUprightConstraint' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, StayUprightStiffness) == 0x000194, "Member 'UBuoyancyComponent::StayUprightStiffness' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, StayUprightDamping) == 0x000198, "Member 'UBuoyancyComponent::StayUprightDamping' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, StayUprightDesiredRotation) == 0x00019C, "Member 'UBuoyancyComponent::StayUprightDesiredRotation' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, EnableWaveForces) == 0x0001A8, "Member 'UBuoyancyComponent::EnableWaveForces' has a wrong offset!");
static_assert(offsetof(UBuoyancyComponent, WaveForceMultiplier) == 0x0001AC, "Member 'UBuoyancyComponent::WaveForceMultiplier' has a wrong offset!");

// Class OceanPlugin.BuoyantDestructible
// 0x0008 (0x03A8 - 0x03A0)
class ABuoyantDestructible final : public AActor
{
public:
	class UBuoyantDestructibleComponent*          BuoyantDestructibleComponent;                      // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuoyantDestructible">();
	}
	static class ABuoyantDestructible* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuoyantDestructible>();
	}
};
static_assert(alignof(ABuoyantDestructible) == 0x000008, "Wrong alignment on ABuoyantDestructible");
static_assert(sizeof(ABuoyantDestructible) == 0x0003A8, "Wrong size on ABuoyantDestructible");
static_assert(offsetof(ABuoyantDestructible, BuoyantDestructibleComponent) == 0x0003A0, "Member 'ABuoyantDestructible::BuoyantDestructibleComponent' has a wrong offset!");

// Class OceanPlugin.BuoyantMeshComponent
// 0x0060 (0x0870 - 0x0810)
class UBuoyantMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVerticalForcesOnly;                               // 0x0810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWaterPatch;                                    // 0x0811(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStaticForces;                                  // 0x0812(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDynamicForces;                                 // 0x0813(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_814[0x4];                                      // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOceanManager*                          OceanManager;                                      // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawForceArrows;                                  // 0x0820(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawWaterline;                                    // 0x0821(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawVertices;                                     // 0x0822(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawTriangles;                                    // 0x0823(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawSubtriangles;                                 // 0x0824(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_825[0x3];                                      // 0x0825(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceArrowSize;                                    // 0x0828(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMeshDensity;                              // 0x082C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82D[0x3];                                      // 0x082D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshDensity;                                       // 0x0830(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMass;                                     // 0x0834(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_835[0x3];                                      // 0x0835(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Mass;                                              // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDensity;                                      // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x28];                                     // 0x0840(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UWaterHeightmapComponent*               WaterHeightmap;                                    // 0x0868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuoyantMeshComponent">();
	}
	static class UBuoyantMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuoyantMeshComponent>();
	}
};
static_assert(alignof(UBuoyantMeshComponent) == 0x000010, "Wrong alignment on UBuoyantMeshComponent");
static_assert(sizeof(UBuoyantMeshComponent) == 0x000870, "Wrong size on UBuoyantMeshComponent");
static_assert(offsetof(UBuoyantMeshComponent, bVerticalForcesOnly) == 0x000810, "Member 'UBuoyantMeshComponent::bVerticalForcesOnly' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bUseWaterPatch) == 0x000811, "Member 'UBuoyantMeshComponent::bUseWaterPatch' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bUseStaticForces) == 0x000812, "Member 'UBuoyantMeshComponent::bUseStaticForces' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bUseDynamicForces) == 0x000813, "Member 'UBuoyantMeshComponent::bUseDynamicForces' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, OceanManager) == 0x000818, "Member 'UBuoyantMeshComponent::OceanManager' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bDrawForceArrows) == 0x000820, "Member 'UBuoyantMeshComponent::bDrawForceArrows' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bDrawWaterline) == 0x000821, "Member 'UBuoyantMeshComponent::bDrawWaterline' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bDrawVertices) == 0x000822, "Member 'UBuoyantMeshComponent::bDrawVertices' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bDrawTriangles) == 0x000823, "Member 'UBuoyantMeshComponent::bDrawTriangles' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bDrawSubtriangles) == 0x000824, "Member 'UBuoyantMeshComponent::bDrawSubtriangles' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, ForceArrowSize) == 0x000828, "Member 'UBuoyantMeshComponent::ForceArrowSize' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bOverrideMeshDensity) == 0x00082C, "Member 'UBuoyantMeshComponent::bOverrideMeshDensity' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, MeshDensity) == 0x000830, "Member 'UBuoyantMeshComponent::MeshDensity' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, bOverrideMass) == 0x000834, "Member 'UBuoyantMeshComponent::bOverrideMass' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, Mass) == 0x000838, "Member 'UBuoyantMeshComponent::Mass' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, WaterDensity) == 0x00083C, "Member 'UBuoyantMeshComponent::WaterDensity' has a wrong offset!");
static_assert(offsetof(UBuoyantMeshComponent, WaterHeightmap) == 0x000868, "Member 'UBuoyantMeshComponent::WaterHeightmap' has a wrong offset!");

// Class OceanPlugin.CustomVehicleController
// 0x0008 (0x06D8 - 0x06D0)
class ACustomVehicleController final : public APlayerController
{
public:
	class APawn*                                  PlayerPawn;                                        // 0x06D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DrawBuoyancyPoints();
	void EnableBuoyancy();
	void EnterVehicle(class APawn* Vehicle);
	void ExitVehicle();
	bool GetIsDriving();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomVehicleController">();
	}
	static class ACustomVehicleController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomVehicleController>();
	}
};
static_assert(alignof(ACustomVehicleController) == 0x000008, "Wrong alignment on ACustomVehicleController");
static_assert(sizeof(ACustomVehicleController) == 0x0006D8, "Wrong size on ACustomVehicleController");
static_assert(offsetof(ACustomVehicleController, PlayerPawn) == 0x0006D0, "Member 'ACustomVehicleController::PlayerPawn' has a wrong offset!");

// Class OceanPlugin.FishManager
// 0x0058 (0x03F8 - 0x03A0)
class AFishManager final : public AActor
{
public:
	TArray<class UClass*>                         flockTypes;                                        // 0x03A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 numInFlock;                                        // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         minZ;                                              // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxZ;                                              // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         underwaterBoxLength;                               // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          attachToPlayer;                                    // 0x03CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMode;                                         // 0x03CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CE[0x2];                                      // 0x03CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 playerType;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FishManager">();
	}
	static class AFishManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFishManager>();
	}
};
static_assert(alignof(AFishManager) == 0x000008, "Wrong alignment on AFishManager");
static_assert(sizeof(AFishManager) == 0x0003F8, "Wrong size on AFishManager");
static_assert(offsetof(AFishManager, flockTypes) == 0x0003A0, "Member 'AFishManager::flockTypes' has a wrong offset!");
static_assert(offsetof(AFishManager, numInFlock) == 0x0003B0, "Member 'AFishManager::numInFlock' has a wrong offset!");
static_assert(offsetof(AFishManager, minZ) == 0x0003C0, "Member 'AFishManager::minZ' has a wrong offset!");
static_assert(offsetof(AFishManager, maxZ) == 0x0003C4, "Member 'AFishManager::maxZ' has a wrong offset!");
static_assert(offsetof(AFishManager, underwaterBoxLength) == 0x0003C8, "Member 'AFishManager::underwaterBoxLength' has a wrong offset!");
static_assert(offsetof(AFishManager, attachToPlayer) == 0x0003CC, "Member 'AFishManager::attachToPlayer' has a wrong offset!");
static_assert(offsetof(AFishManager, DebugMode) == 0x0003CD, "Member 'AFishManager::DebugMode' has a wrong offset!");
static_assert(offsetof(AFishManager, playerType) == 0x0003D0, "Member 'AFishManager::playerType' has a wrong offset!");

// Class OceanPlugin.FlockFish
// 0x0180 (0x0580 - 0x0400)
class AFlockFish final : public APawn
{
public:
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       FishInteractionSphere;                             // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isLeader;                                          // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         enemyTypes;                                        // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         preyTypes;                                         // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UClass*                                 neighborType;                                      // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         followDist;                                        // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         turnSpeed;                                         // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         turnFrequency;                                     // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         hungerResetTime;                                   // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         distBehindSpeedUpRange;                            // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeperationDistanceMultiplier;                      // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeDistanceMultiplier;                            // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FleeAccelerationMultiplier;                        // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseAccelerationMultiplier;                       // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeekDecelerationMultiplier;                        // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidForceMultiplier;                              // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceForce;                                    // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 playerType;                                        // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                underwaterMin;                                     // 0x0488(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                underwaterMax;                                     // 0x0494(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CustomZSeekMin;                                    // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomZSeekMax;                                    // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NumNeighborsToEvaluate;                            // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateEveryTick;                                   // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugMode;                                         // 0x04C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0xBF];                                     // 0x04C1(0x00BF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* activatedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* activatedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlockFish">();
	}
	static class AFlockFish* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlockFish>();
	}
};
static_assert(alignof(AFlockFish) == 0x000008, "Wrong alignment on AFlockFish");
static_assert(sizeof(AFlockFish) == 0x000580, "Wrong size on AFlockFish");
static_assert(offsetof(AFlockFish, FishInteractionSphere) == 0x000410, "Member 'AFlockFish::FishInteractionSphere' has a wrong offset!");
static_assert(offsetof(AFlockFish, isLeader) == 0x000418, "Member 'AFlockFish::isLeader' has a wrong offset!");
static_assert(offsetof(AFlockFish, enemyTypes) == 0x000420, "Member 'AFlockFish::enemyTypes' has a wrong offset!");
static_assert(offsetof(AFlockFish, preyTypes) == 0x000430, "Member 'AFlockFish::preyTypes' has a wrong offset!");
static_assert(offsetof(AFlockFish, neighborType) == 0x000440, "Member 'AFlockFish::neighborType' has a wrong offset!");
static_assert(offsetof(AFlockFish, followDist) == 0x000448, "Member 'AFlockFish::followDist' has a wrong offset!");
static_assert(offsetof(AFlockFish, Speed) == 0x00044C, "Member 'AFlockFish::Speed' has a wrong offset!");
static_assert(offsetof(AFlockFish, MaxSpeed) == 0x000450, "Member 'AFlockFish::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AFlockFish, turnSpeed) == 0x000454, "Member 'AFlockFish::turnSpeed' has a wrong offset!");
static_assert(offsetof(AFlockFish, turnFrequency) == 0x000458, "Member 'AFlockFish::turnFrequency' has a wrong offset!");
static_assert(offsetof(AFlockFish, hungerResetTime) == 0x00045C, "Member 'AFlockFish::hungerResetTime' has a wrong offset!");
static_assert(offsetof(AFlockFish, distBehindSpeedUpRange) == 0x000460, "Member 'AFlockFish::distBehindSpeedUpRange' has a wrong offset!");
static_assert(offsetof(AFlockFish, SeperationDistanceMultiplier) == 0x000464, "Member 'AFlockFish::SeperationDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, FleeDistanceMultiplier) == 0x000468, "Member 'AFlockFish::FleeDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, FleeAccelerationMultiplier) == 0x00046C, "Member 'AFlockFish::FleeAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, ChaseAccelerationMultiplier) == 0x000470, "Member 'AFlockFish::ChaseAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, SeekDecelerationMultiplier) == 0x000474, "Member 'AFlockFish::SeekDecelerationMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, AvoidForceMultiplier) == 0x000478, "Member 'AFlockFish::AvoidForceMultiplier' has a wrong offset!");
static_assert(offsetof(AFlockFish, AvoidanceForce) == 0x00047C, "Member 'AFlockFish::AvoidanceForce' has a wrong offset!");
static_assert(offsetof(AFlockFish, playerType) == 0x000480, "Member 'AFlockFish::playerType' has a wrong offset!");
static_assert(offsetof(AFlockFish, underwaterMin) == 0x000488, "Member 'AFlockFish::underwaterMin' has a wrong offset!");
static_assert(offsetof(AFlockFish, underwaterMax) == 0x000494, "Member 'AFlockFish::underwaterMax' has a wrong offset!");
static_assert(offsetof(AFlockFish, CustomZSeekMin) == 0x0004A0, "Member 'AFlockFish::CustomZSeekMin' has a wrong offset!");
static_assert(offsetof(AFlockFish, CustomZSeekMax) == 0x0004A4, "Member 'AFlockFish::CustomZSeekMax' has a wrong offset!");
static_assert(offsetof(AFlockFish, NumNeighborsToEvaluate) == 0x0004A8, "Member 'AFlockFish::NumNeighborsToEvaluate' has a wrong offset!");
static_assert(offsetof(AFlockFish, UpdateEveryTick) == 0x0004AC, "Member 'AFlockFish::UpdateEveryTick' has a wrong offset!");
static_assert(offsetof(AFlockFish, DebugMode) == 0x0004C0, "Member 'AFlockFish::DebugMode' has a wrong offset!");

// Class OceanPlugin.InfiniteSystemComponent
// 0x0030 (0x0330 - 0x0300)
class UInfiniteSystemComponent final : public USceneComponent
{
public:
	bool                                          UpdateInEditor;                                    // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFollowMethod                                 FollowMethod;                                      // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridSnapSize;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLookAtDistance;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleByDistance;                                   // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleDistanceFactor;                               // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleStartDistance;                                // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfiniteSystemComponent">();
	}
	static class UInfiniteSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfiniteSystemComponent>();
	}
};
static_assert(alignof(UInfiniteSystemComponent) == 0x000008, "Wrong alignment on UInfiniteSystemComponent");
static_assert(sizeof(UInfiniteSystemComponent) == 0x000330, "Wrong size on UInfiniteSystemComponent");
static_assert(offsetof(UInfiniteSystemComponent, UpdateInEditor) == 0x000300, "Member 'UInfiniteSystemComponent::UpdateInEditor' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, FollowMethod) == 0x000301, "Member 'UInfiniteSystemComponent::FollowMethod' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, GridSnapSize) == 0x000304, "Member 'UInfiniteSystemComponent::GridSnapSize' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, MaxLookAtDistance) == 0x000308, "Member 'UInfiniteSystemComponent::MaxLookAtDistance' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, ScaleByDistance) == 0x00030C, "Member 'UInfiniteSystemComponent::ScaleByDistance' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, ScaleDistanceFactor) == 0x000310, "Member 'UInfiniteSystemComponent::ScaleDistanceFactor' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, ScaleStartDistance) == 0x000314, "Member 'UInfiniteSystemComponent::ScaleStartDistance' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, ScaleMin) == 0x000318, "Member 'UInfiniteSystemComponent::ScaleMin' has a wrong offset!");
static_assert(offsetof(UInfiniteSystemComponent, ScaleMax) == 0x00031C, "Member 'UInfiniteSystemComponent::ScaleMax' has a wrong offset!");

// Class OceanPlugin.TimeManager
// 0x00C8 (0x0468 - 0x03A0)
class ATimeManager final : public AActor
{
public:
	struct FTimeDate                              CurrentLocalTime;                                  // 0x03A0(0x001C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Latitude;                                          // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Longitude;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OffsetUTC;                                         // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OffsetDST;                                         // 0x03C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDaylightSavings;                             // 0x03CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDaylightSavingsActive;                            // 0x03CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CE[0x2];                                      // 0x03CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeScaleMultiplier;                               // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarTime;                                         // 0x03D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalClockTime;                                    // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeCorrection;                                    // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LSTM;                                              // 0x03E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DayOfYear;                                         // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EoT;                                               // 0x03E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarAltAngle;                                     // 0x03EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarDeclination;                                  // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarAzimuth;                                      // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolarHRA;                                          // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SiderealTime;                                      // 0x03FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarAltAngle;                                     // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarHRA;                                          // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarDeclination;                                  // 0x0408(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarAzimuth;                                      // 0x040C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarRightAsc;                                     // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LunarElapsedDays;                                  // 0x0414(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EcLongitude;                                       // 0x0418(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EcLatitude;                                        // 0x041C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EcDistance;                                        // 0x0420(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartL;                                             // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartM;                                             // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartF;                                             // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x38];                                     // 0x0430(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FRotator CalculateMoonAngle();
	float CalculateMoonPhase();
	struct FRotator CalculateSunAngle();
	int32 GetDayOfYear(const struct FTimeDate& Time);
	float GetDayPhase();
	int32 GetDaysInMonth(int32 Year, int32 Month);
	int32 GetDaysInYear(int32 Year);
	float GetElapsedDayInMinutes();
	float GetYearPhase();
	void IncrementTime(float DeltaSeconds);
	void InitializeCalendar(const struct FTimeDate& Time);
	bool IsLeapYear(int32 Year);
	void SetCurrentLocalTime(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeManager">();
	}
	static class ATimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeManager>();
	}
};
static_assert(alignof(ATimeManager) == 0x000008, "Wrong alignment on ATimeManager");
static_assert(sizeof(ATimeManager) == 0x000468, "Wrong size on ATimeManager");
static_assert(offsetof(ATimeManager, CurrentLocalTime) == 0x0003A0, "Member 'ATimeManager::CurrentLocalTime' has a wrong offset!");
static_assert(offsetof(ATimeManager, Latitude) == 0x0003BC, "Member 'ATimeManager::Latitude' has a wrong offset!");
static_assert(offsetof(ATimeManager, Longitude) == 0x0003C0, "Member 'ATimeManager::Longitude' has a wrong offset!");
static_assert(offsetof(ATimeManager, OffsetUTC) == 0x0003C4, "Member 'ATimeManager::OffsetUTC' has a wrong offset!");
static_assert(offsetof(ATimeManager, OffsetDST) == 0x0003C8, "Member 'ATimeManager::OffsetDST' has a wrong offset!");
static_assert(offsetof(ATimeManager, bAllowDaylightSavings) == 0x0003CC, "Member 'ATimeManager::bAllowDaylightSavings' has a wrong offset!");
static_assert(offsetof(ATimeManager, bDaylightSavingsActive) == 0x0003CD, "Member 'ATimeManager::bDaylightSavingsActive' has a wrong offset!");
static_assert(offsetof(ATimeManager, TimeScaleMultiplier) == 0x0003D0, "Member 'ATimeManager::TimeScaleMultiplier' has a wrong offset!");
static_assert(offsetof(ATimeManager, SolarTime) == 0x0003D4, "Member 'ATimeManager::SolarTime' has a wrong offset!");
static_assert(offsetof(ATimeManager, LocalClockTime) == 0x0003D8, "Member 'ATimeManager::LocalClockTime' has a wrong offset!");
static_assert(offsetof(ATimeManager, TimeCorrection) == 0x0003DC, "Member 'ATimeManager::TimeCorrection' has a wrong offset!");
static_assert(offsetof(ATimeManager, LSTM) == 0x0003E0, "Member 'ATimeManager::LSTM' has a wrong offset!");
static_assert(offsetof(ATimeManager, DayOfYear) == 0x0003E4, "Member 'ATimeManager::DayOfYear' has a wrong offset!");
static_assert(offsetof(ATimeManager, EoT) == 0x0003E8, "Member 'ATimeManager::EoT' has a wrong offset!");
static_assert(offsetof(ATimeManager, SolarAltAngle) == 0x0003EC, "Member 'ATimeManager::SolarAltAngle' has a wrong offset!");
static_assert(offsetof(ATimeManager, SolarDeclination) == 0x0003F0, "Member 'ATimeManager::SolarDeclination' has a wrong offset!");
static_assert(offsetof(ATimeManager, SolarAzimuth) == 0x0003F4, "Member 'ATimeManager::SolarAzimuth' has a wrong offset!");
static_assert(offsetof(ATimeManager, SolarHRA) == 0x0003F8, "Member 'ATimeManager::SolarHRA' has a wrong offset!");
static_assert(offsetof(ATimeManager, SiderealTime) == 0x0003FC, "Member 'ATimeManager::SiderealTime' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarAltAngle) == 0x000400, "Member 'ATimeManager::LunarAltAngle' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarHRA) == 0x000404, "Member 'ATimeManager::LunarHRA' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarDeclination) == 0x000408, "Member 'ATimeManager::LunarDeclination' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarAzimuth) == 0x00040C, "Member 'ATimeManager::LunarAzimuth' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarRightAsc) == 0x000410, "Member 'ATimeManager::LunarRightAsc' has a wrong offset!");
static_assert(offsetof(ATimeManager, LunarElapsedDays) == 0x000414, "Member 'ATimeManager::LunarElapsedDays' has a wrong offset!");
static_assert(offsetof(ATimeManager, EcLongitude) == 0x000418, "Member 'ATimeManager::EcLongitude' has a wrong offset!");
static_assert(offsetof(ATimeManager, EcLatitude) == 0x00041C, "Member 'ATimeManager::EcLatitude' has a wrong offset!");
static_assert(offsetof(ATimeManager, EcDistance) == 0x000420, "Member 'ATimeManager::EcDistance' has a wrong offset!");
static_assert(offsetof(ATimeManager, PartL) == 0x000424, "Member 'ATimeManager::PartL' has a wrong offset!");
static_assert(offsetof(ATimeManager, PartM) == 0x000428, "Member 'ATimeManager::PartM' has a wrong offset!");
static_assert(offsetof(ATimeManager, PartF) == 0x00042C, "Member 'ATimeManager::PartF' has a wrong offset!");

}

