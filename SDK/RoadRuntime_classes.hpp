#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RoadRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "RoadRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class RoadRuntime.CrossActor
// 0x0030 (0x03E0 - 0x03B0)
class ACrossActor final : public AStaticMeshActor
{
public:
	class FString                                 UniqueKey;                                         // 0x03B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCrossActorManager>             SideActors;                                        // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCrossMeshManager>              SideMeshes;                                        // 0x03D0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void DestroySideObjects();
	void PushSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void PushSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void UpdateSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);
	void UpdateSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, bool IsEnable, bool IsNormalized);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossActor">();
	}
	static class ACrossActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrossActor>();
	}
};
static_assert(alignof(ACrossActor) == 0x000008, "Wrong alignment on ACrossActor");
static_assert(sizeof(ACrossActor) == 0x0003E0, "Wrong size on ACrossActor");
static_assert(offsetof(ACrossActor, UniqueKey) == 0x0003B0, "Member 'ACrossActor::UniqueKey' has a wrong offset!");
static_assert(offsetof(ACrossActor, SideActors) == 0x0003C0, "Member 'ACrossActor::SideActors' has a wrong offset!");
static_assert(offsetof(ACrossActor, SideMeshes) == 0x0003D0, "Member 'ACrossActor::SideMeshes' has a wrong offset!");

// Class RoadRuntime.RoadActor
// 0x0078 (0x0418 - 0x03A0)
class ARoadActor final : public AActor
{
public:
	ESplineMeshAxis                               SplineMeshAxis;                                    // 0x03A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalOffset;                                       // 0x03A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ARoadActor*                             Father;                                            // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueKey;                                         // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       Spline;                                            // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x03D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segmentation;                                      // 0x03D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepGeneration;                                    // 0x03D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x03DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RoadMesh;                                          // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           RoadMeshesComp;                                    // 0x03E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSideActorManager>              SideActors;                                        // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSideMeshManager>               SideMeshes;                                        // 0x0408(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static float ApproxLength(const struct FInterpCurveVector& SplineInfo, const float Start, const float End, const int32 ApproxSections);

	void AddSplineMesh(int32 MeshIndex);
	void ClearSplineMeshes();
	void DestroySideObjects();
	void PushSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void PushSideMesh(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSegment(int32 SegmentIndex, class USplineComponent* SplineComponent, class UStaticMesh* StaticMesh, ESplineMeshAxis InAxis);
	void UpdateSideActor(TSubclassOf<class AActor> InPrototype, const struct FVector& ActorRelativeLocation, const struct FRotator& ActorRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSideMeshes(class UStaticMesh* InPrototype, const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation, int32 SocketIndex, int32 InShift, int32 InSpacing, bool IsEnable, bool IsNormalized);
	void UpdateSplineMesh(int32 MeshIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoadActor">();
	}
	static class ARoadActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoadActor>();
	}
};
static_assert(alignof(ARoadActor) == 0x000008, "Wrong alignment on ARoadActor");
static_assert(sizeof(ARoadActor) == 0x000418, "Wrong size on ARoadActor");
static_assert(offsetof(ARoadActor, SplineMeshAxis) == 0x0003A0, "Member 'ARoadActor::SplineMeshAxis' has a wrong offset!");
static_assert(offsetof(ARoadActor, LocalOffset) == 0x0003A4, "Member 'ARoadActor::LocalOffset' has a wrong offset!");
static_assert(offsetof(ARoadActor, Father) == 0x0003B0, "Member 'ARoadActor::Father' has a wrong offset!");
static_assert(offsetof(ARoadActor, UniqueKey) == 0x0003B8, "Member 'ARoadActor::UniqueKey' has a wrong offset!");
static_assert(offsetof(ARoadActor, Spline) == 0x0003C8, "Member 'ARoadActor::Spline' has a wrong offset!");
static_assert(offsetof(ARoadActor, Index_0) == 0x0003D0, "Member 'ARoadActor::Index_0' has a wrong offset!");
static_assert(offsetof(ARoadActor, Segmentation) == 0x0003D4, "Member 'ARoadActor::Segmentation' has a wrong offset!");
static_assert(offsetof(ARoadActor, StepGeneration) == 0x0003D8, "Member 'ARoadActor::StepGeneration' has a wrong offset!");
static_assert(offsetof(ARoadActor, Size) == 0x0003DC, "Member 'ARoadActor::Size' has a wrong offset!");
static_assert(offsetof(ARoadActor, RoadMesh) == 0x0003E0, "Member 'ARoadActor::RoadMesh' has a wrong offset!");
static_assert(offsetof(ARoadActor, RoadMeshesComp) == 0x0003E8, "Member 'ARoadActor::RoadMeshesComp' has a wrong offset!");
static_assert(offsetof(ARoadActor, SideActors) == 0x0003F8, "Member 'ARoadActor::SideActors' has a wrong offset!");
static_assert(offsetof(ARoadActor, SideMeshes) == 0x000408, "Member 'ARoadActor::SideMeshes' has a wrong offset!");

}

